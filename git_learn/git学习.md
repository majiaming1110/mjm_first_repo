# GIT 学习

## GIT --- 基本操作
作为第一个章节，介绍git最基础的应用

### 名字和邮箱设置
因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址
```
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
```


### 创建版本库
```
$ mkdir XXX
$ cd XXX
$ pwd //检查路径
```
```
$ git init
```


### 添加文件到版本库
#### git add
```
$ git add <file>
```
#### git commit
```
$ git commit -m "wrote a readme file"
```
#### 一次性提交多个文件（多个add一个commit）
```
$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."
```

### 显示文本内容
```
$ cat <file>
```

### 查看仓库当前的状态
```
git status
```
>![alt text](image3.png)
如果显示这个内容，说明暂存区有文件待提交到分支

>![alt text](image4.png)
如果显示这个内容，说明工作区有文件待提交到暂存区

### 查看不同（文件修改了哪里）
```
git diff <file> 
```

### 查看版本控制的历史记录
```
git log
```
```
git log --pretty=oneline //精简版
```

### 版本回退
>Git中，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为`commit`。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个`commit`恢复，然后继续工作，而不是把几个月的工作成果全部丢失。

首先，Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个^比较容易数不过来，所以写成`HEAD~100`
```
$ git reset --hard HEAD^
```
-hard参数的意义后面再讲，现在先放心使用

### 回退后的版本恢复
在上一步的回退之后，如果输入`git log`，会发现回退前的版本不见了，那么如何回到之前那个不见的版本呢？
办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个目标版本的commit id是1094adb...，于是就可以指定回到未来的某个版本：
```
$ git reset --hard 1094a //commit id 只用写前几位就可以
```
如果在回退之后就关闭了git，那么可以使用以下指令来查看git的历史纪录：
```
$ git reflog
```

### 暂存区和工作区
`git add`命令实际上就是把要提交的所有修改放到暂存区（`Stage`），然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。
![alt text](image.png)

![alt text](image-1.png)

### 撤销修改
1. 以下命令可以丢弃工作区的修改：
```
$ git checkout -- <file>
```
命令`git checkout -- readme.txt`意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：
* 一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
* 一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。

`git checkout -- file`命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到`git checkout`命令

2. 以下命令可以丢弃暂存区的修改，重新放回工作区：
将暂存区中指定的文件恢复到与上一次提交的状态一致，但保留工作区中的修改。
```
$ git reset HEAD <file> //HEAD表示最新的版本
```
### 文件的删除
__1. 删除文件__
```
$ rm <file>
```
__2. （查看状态）__
```
$ git status
```
可见，git会提示：文件已经被删除：
![alt text](image5.png)
此时，有两个选择：确认删除 或 后悔

__3. 如果确认想要删除：__
```
$ git rm <file>
$ git commit -m "remove XXX.txt"
```
>__骚操作:__ 其实此处使用`git add`替代`git rm`也可以，因为git是基于修改的，而`git add`本质上就是将一个"修改"从工作区上传到暂存区，__删除也是一个操作__，因此理论上也可以使用`git add`；但是由于"add"在英文中添加的含义可能造成歧义，所以使用`git rm`更符合逻辑

__4. 如果第二步之后反悔了，不想删除了：__
```
$ git checkout -- <file>
```
其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”


## GIT --- 远程仓库
本章开始介绍Git的杀手级功能之一：远程仓库
Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。


### 在Github上保存自己的信息
在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，这一部分就不需要了
__1. 创建SSH Key__
在git bsah中：
```
$ ssh-keygen -t rsa -C "youremail@example.com"
```
然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码：
![alt text](image6.png)

__2. 登陆GitHub，打开“Account settings”，“SSH Keys”页面__
填上任意Title，在Key文本框里粘贴id_rsa.pub（公钥）文件的内容：
![alt text](image7.png)
为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。
最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。

### 添加远程仓库
现在的情景是，我已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作

__1.创建新仓库__
step1.
![alt text](1.png)
step2.
![alt text](2.png)
step3.
在本地的git.bash中输入：（注意,github会有提示，选择ssh而不是https）
```
$ git remote add origin git@github.com:majiaming1110/mjm_first_repo.git
$ git branch -M main //重命名当前分支为 main
$ git push -u origin main //将当前目录（分支）推送到远程
```
>由于远程库是空的，我们第一次推送`master`分支时，加上了`-u`参数，Git不但会把`本地的master`分支内容推送的远程新的`master`分支，还会把`本地的master分支`和`远程的master分支`关联起来，在以后的推送或者拉取时就可以简化命令。

>如果不小心选了https，想要取消绑定，则应该：使用`git remote -v`查看当前远程仓库地址，通常情况下，名字是‘origin’，然后使用`git remote remove origin`解除绑定

>使用`ssh`速度最快；使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，__但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https__

---

至此，就完成了远程仓库的搭建！

---

### 远程仓库的上传
在创建完成后，就可以使用以下命令 把本地master分支 的最新修改推送至GitHub，现在，就拥有了真正的分布式版本库
```
$ git push origin master
```

### 从远程仓库的克隆
假设在github上有一个仓库AAA，属于一个叫CCC的人，那再本地的git bash中输入以下指令：
```
$ git clone git@github.com:CCC/AAA.git
```
就可以实现仓库的克隆，在本地的git目录下，就会生成一个和远程仓库内容一模一样的`AAA.git`

## GIT --- 分支管理
分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙可能会合并

分支在实际开发中非常有用。例如，当你准备开发一个新功能并预计需要两周时间时，可以创建一个分支独立进行开发。在第一周完成50%的代码后，如果直接提交到主分支，未完成的代码可能会影响他人的工作。如果等到功能完全开发完成再提交，又有丢失进度的风险。

有了分支，你可以在自己的分支上自由提交，不影响其他人，确保代码库的完整性。开发完成后，再将分支合并到主分支，既保证了安全性，又不影响他人的工作。

虽然其他版本控制系统（如SVN）也有分支管理，但创建和切换分支的速度很慢，导致分支功能难以使用。Git则不同，创建、切换和删除分支都非常快，通常在一秒内完成，无论版本库的大小如何。

### 分支的创建
使用以下命令 __创建 *并切换* 到新的名为'dev'的分支__
```
$ git checkout -b dev //如果只是切换到已有的分支就不用‘-b’
```
以下两句代码实现的是相同的效果：
```
$ git branch dev
$ git checkout dev
```
>创建完成后，可以使用 __`git branch`__ 查看当前的分支情况, 该命令会列出所有分支，当前分支前面会标一个‘*’号

>在新版本的git中，为了防止checkout命令一会儿负责撤销一会儿负责分支产生歧义，可以将checkout替换成更符合直觉的 __switch__，只不过使用switch后，当想要创建并切换时，需要加上 __‘-c’__ 而不是‘-b’，也就是 __‘git switch -c dev’__

__然后，所有的操作都和第一节的基本操作一致，只不过现在所有的改动都是在分支上进行了，如果结束后使用 __`git checkout master`__ 切换回到主分支，就会发现分支上的一切改动都在主分支上没有任何痕迹__

### 分支的合并
现在，如果输入以下命令，就可以同步分支和master的进度：
```
$ git merge dev //同样假设分支的名字是'dev'
```

### 分支的删除
当一个分支不再被需要时，运行以下命令删除分支：
```
$ git branch -d dev //同样假设分支的名字是'dev'
```
__因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。__



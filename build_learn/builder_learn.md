## 学习地址
* gcc： `gcc.gnu.org`
* ld：`ftp.gnu.org`
* llvm：`lld.llvm.org`



## 疑问&思考

* llvm是和gcc完全平行的概念，这二者属于不同的编译器
* 对于一般的非RTOS/非操作系统，代码中出现类似`__attribute__ ((section (".XXX")))`的作用是将紧跟的一个函数划分到XXX段，但这句话只是做一个语义识别，只有在`ld`(gcc)/`lld`(llvm)指令执行时，根据ld语法的定义，才会真正将XXX段来划分到实际的存储空间，比如flash/itcm等，`ld`的作用就是将输入的`.o`文件输出成`.elf`文件
* `.o`和`.elf`文件?
* `llvm`中的编译选项`-ffunction_section`？



# 学习总结

* 存储器：
  * **RAM**：断电后数据丢失，快，贵
    * SRAM
      * TCM:
      * DCM:
  * **ROM**：断电数据依然在，慢，便宜
    * EEPROM：可擦除，支持单字节擦除和编程
    * FLASH：可擦除，但只在页/块的颗粒度上擦除，大容量低成本
* 编译后会生成map文件，其中：VMA 是**虚拟内存地址**；LMA 是**加载内存地址**。在程序启动时，通常会有一个启动代码（启动例程）负责将程序或数据从LMA复制到VMA，使得程序可以正常运行
  * 之所以要复制是因为：程序的代码通常存储在`非易失性存储器中（ROM）`中，这类存储器断电不会丢失数据；但是程序在执行时通常需要在更快的存储器（如SRAM）中运行，或者程序需要修改数据而非易失性存储器不能直接修改（。因此，启动时会将程序从LMA加载到RAM中的VMA位置，这个过程称为启动代码的复制或初始化。
    * **LMA**：在非易失性存储器中的实际存储位置，用于存储程序和数据。
    * **VMA**：程序和数据在运行时所在的位置，通常是在易失性存储器（如RAM）中
* 

